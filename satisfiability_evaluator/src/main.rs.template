use rayon::prelude::*;
use std::{
    fs,
    io::Write,
    path::PathBuf,
    sync::{Arc, Mutex},
    time::Instant,
};
use tig_challenges::satisfiability::*;
#[cfg(feature = "local")]
mod ${ALGORITHM};
#[cfg(not(feature = "local"))]
use tig_algorithms::satisfiability::*;

/// Find all `.cnf` files in the given directory.
fn find_cnf_files(dir_path: &str) -> Vec<PathBuf> {
    let mut cnf_files = Vec::new();
    for entry in fs::read_dir(dir_path).unwrap() {
        let path = entry.unwrap().path();
        if !path.is_dir() {
            if let Some(ext) = path.extension().and_then(|s| s.to_str()) {
                if ext.eq_ignore_ascii_case("cnf") {
                    cnf_files.push(path);
                }
            }
        }
    }
    cnf_files
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <directory_path>", args[0]);
        std::process::exit(1);
    }
    let dir_path = &args[1];

    let dataset_name = std::path::Path::new(dir_path)
        .file_name()
        .unwrap()
        .to_string_lossy()
        .to_string();
    let _ = std::fs::create_dir("evaluations");
    let file_path = format!("evaluations/c001_{}_${ALGORITHM}.csv", dataset_name);
    println!("Writing evaluation to: {:?}", file_path);
    let mut eval_file = std::fs::OpenOptions::new()
        .write(true)
        .create(true)
        .open(&file_path)
        .unwrap();
    writeln!(eval_file, "instance_name,ime_milliseconds,status").unwrap();

    let eval_file = Arc::new(Mutex::new(eval_file));

    find_txt_files(dir_path).par_iter().for_each(|file_path| {
        let file_name = file_path.file_name().unwrap().to_string_lossy();
        let txt = fs::read_to_string(&file_path).unwrap();
        let mut lines = txt.lines();
        let mut num_variables = 0;
        let mut num_clauses = 0;
        let mut clauses = Vec::new();

        // Skip comments and find the problem line
        while let Some(line) = lines.next() {
            let trimmed = line.trim();
            if trimmed.starts_with('c') {
                continue;
            } else if trimmed.starts_with("p cnf") {
                let parts: Vec<&str> = trimmed.split_whitespace().collect();
                num_variables = parts[2].parse().unwrap();
                num_clauses = parts[3].parse().unwrap();
                break;
            }
        }

        for line in lines.take(num_clauses) {
            let trimmed = line.trim();
            if trimmed.is_empty() {
                continue;
            }
            let parts: Vec<&str> = trimmed.split_whitespace().collect();
            let clause: Vec<i32> = parts[..parts.len() - 1]
                .iter()
                .map(|s| s.parse::<i32>().unwrap())
                .collect();

            clauses.push(clause);
        }

        let challenge = Challenge {
            seed: [0u8; 32],
            difficulty: Difficulty {
                num_variables,
                clauses_to_variables_percent: (num_variables * 100 / num_clauses) as u32,
            },
            clauses,
        };

        let start_time = Instant::now();
        let result = ${ALGORITHM}::solve_challenge(&challenge);
        let elapsed_ms = start_time.elapsed().as_millis();
        if let Ok(Some(solution)) = result {
            match challenge.verify_solution(&solution) {
                Ok(_) => {
                    println!(
                        "instance: {:?}, result: sat, time: {:4} ms",
                        file_name, elapsed_ms
                    );
                    writeln!(
                        eval_file.lock().unwrap(), "{:?},{},{}",
                        file_name, elapsed_ms, "solution"
                    ).unwrap();
                }
                Err(err) => {
                    // print the error message (wrong var-count or clause index)
                    println!(
                        "instance: {:?}, result: invalid solution â€” {}",
                        file_name, err
                    );
                    writeln!(
                        eval_file.lock().unwrap(), "{:?},{},{}",
                        file_name, elapsed_ms, format!("\"invalid_solution: {}\"", err)
                    ).unwrap();
                }
            }
        } else {
            println!("instance: {:?}, result: no solution", file_name);
            writeln!(
                eval_file.lock().unwrap(), "{:?},{},{}",
                file_name, elapsed_ms, "no_solution"
            ).unwrap();
        }
    });
}
