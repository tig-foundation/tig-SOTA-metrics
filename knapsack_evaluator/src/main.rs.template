use rayon::prelude::*;
use std::{
    fs,
    io::Write,
    path::PathBuf,
    sync::{Arc, Mutex},
    time::Instant,
};
use tig_challenges::knapsack::*;
#[cfg(feature = "local")]
mod ${ALGORITHM};
#[cfg(not(feature = "local"))]
use tig_algorithms::knapsack::*;

fn find_txt_files(dir_path: &str) -> Vec<PathBuf> {
    let mut txt_files = Vec::new();
    let paths = fs::read_dir(dir_path).unwrap();

    for path_result in paths {
        let path = path_result.unwrap().path();

        // Skip directories - only process files in the immediate folder
        if !path.is_dir() {
            if let Some(extension) = path.extension() {
                // Check if the file has a .txt extension
                if extension.to_string_lossy().to_lowercase() == "txt" {
                    txt_files.push(path);
                }
            }
        }
    }

    txt_files
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <directory_path>", args[0]);
        std::process::exit(1);
    }

    let dir_path = &args[1];

    let dataset_name = std::path::Path::new(dir_path)
        .file_name()
        .unwrap()
        .to_string_lossy()
        .to_string();
    let _ = std::fs::create_dir("evaluations");
    let file_path = format!("evaluations/c003_{}_${ALGORITHM}.csv", dataset_name);
    println!("Writing evaluation to: {:?}", file_path);
    let mut eval_file = std::fs::OpenOptions::new()
        .write(true)
        .create(true)
        .open(&file_path)
        .unwrap();
    writeln!(eval_file, "instance,knapsack_value,baseline_value,gap_percent,time_milliseconds,status").unwrap();

    let eval_file = Arc::new(Mutex::new(eval_file));

    find_txt_files(dir_path).par_iter().for_each(|file_path| {
        let file_name = file_path.file_name().unwrap().to_string_lossy();
        let txt = std::fs::read_to_string(&file_path).unwrap();
        let lines: Vec<&str> = txt.split("\n").collect();

        let first: Vec<&str> = lines[0].split_whitespace().collect();
        let num_items = first[0].parse::<usize>().unwrap();
        let num_values = first[1].parse::<usize>().unwrap();
        let weights: Vec<u32> = lines[num_values + 1]
            .split_whitespace()
            .map(|s| s.parse::<u32>().unwrap())
            .collect();
        let max_weight = lines[num_values + 2].parse::<u32>().unwrap();
        let best_known_value = lines[num_values + 3].parse::<u32>().unwrap();

        let mut values = vec![0; num_items];
        let mut interaction_values = vec![vec![0; num_items]; num_items];
        let mut warn_float = false;
        for line in lines[1..num_values + 1].iter() {
            let parts: Vec<&str> = line.split_whitespace().collect();
            let item1 = parts[0].parse::<usize>().unwrap();
            let item2 = parts[1].parse::<usize>().unwrap();
            let value = parts[2].parse::<f32>().unwrap();
            if value.fract() != 0.0 {
                warn_float = true;
            }
            if (item1 == item2) {
                values[item1] = value as u32;
            } else {
                interaction_values[item1][item2] = value as i32;
                interaction_values[item2][item1] = value as i32;
            }
        }
        if warn_float {
            eprintln!("WARNING: {} contains float values, this may cause problems as we convert to unsigned integer", file_name);
        }

        let instance = SubInstance {
            seed: [0; 32],
            difficulty: Difficulty {
                num_items,
                better_than_baseline: 0,
            },
            weights,
            values,
            interaction_values,
            max_weight,
            baseline_value: best_known_value,
        };
        let mut challenge = Challenge {
            seed: instance.seed.clone(),
            difficulty: instance.difficulty.clone(),
            sub_instances: vec![instance],
        };

        // Solve and time
        let mut start_time = Instant::now();
        let mut result = ${ALGORITHM}::solve_challenge(&challenge);
        if !result.as_ref().is_ok_and(|x| x.is_some()) {
            start_time = Instant::now();
            challenge.sub_instances.get_mut(0).unwrap().baseline_value = (best_known_value as f32 * 0.995) as u32;
            result = ${ALGORITHM}::solve_challenge(&challenge);
        }
        let elapsed_ms = start_time.elapsed().as_millis();
        if let Ok(Some(solution)) = result {
            let instance = &challenge.sub_instances[0];
            let instance_solution = &solution.sub_solutions[0];
            match instance.verify_solution(&instance_solution) {
                Ok(_) => {
                    let v = calculate_total_value(
                        &instance_solution.items,
                        &instance.values,
                        &instance.interaction_values,
                    );
                    let gap = ((best_known_value as f32 / v as f32) - 1.0) * 100.0;
                    println!("instance: {:?}\tknapsack_value: {:10.0}\tBKS: {:10.0}\tgap: {}%\ttime: {:4.3}ms", 
                        file_name, v, best_known_value, gap, elapsed_ms);
                    writeln!(
                        eval_file.lock().unwrap(), "{:?},{},{},{:.6},{:.6},{}",
                        file_name, v, best_known_value, gap, elapsed_ms, "solution"
                    ).unwrap();
                }
                Err(err) => {
                    println!("instance: {:?}, knapsack_value: invalid solution", file_name);
                    writeln!(
                        eval_file.lock().unwrap(), "{:?},{},{},{:.6},{:.6},{}",
                        file_name, 0, best_known_value, 0.0, elapsed_ms, format!("\"invalid_solution: {}\"", err)
                    ).unwrap();
                }
            }
        } else {
            println!("instance: {:?}, knapsack_value: no solution", file_name);
            writeln!(
                eval_file.lock().unwrap(), "{:?},{},{},{:.6},{:.6},{}",
                file_name, 0, best_known_value, 0.0, elapsed_ms, "no_solution"
            ).unwrap();
        }
    });
}
